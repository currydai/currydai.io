<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" >

<title>【编程】常用设计模式总结(上) | Currydai</title>

<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">

<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous">
<link rel="shortcut icon" href="https://currydai.com/favicon.ico?v=1621440894256">
<link rel="stylesheet" href="https://currydai.com/styles/main.css">


  
    <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css" />
  

  


<link rel="stylesheet" href="https://unpkg.com/aos@next/dist/aos.css" />
<script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>



    <meta name="description" content="1.设计模式
设计模式主要是为了解决某类重复出现的问题而出现的一套成功或有效的解决方案，设计模式提供一种讨论软件设计的公共语言，使得熟练设计者的设计经验可以被初学者和其他设计者掌握。设计模式还为软件重构提供了目标。 每个模式都描述了一个在我..." />
    <meta name="keywords" content="" />
  </head>
  <body>
    <div id="app" class="main">

      <div class="sidebar" :class="{ 'full-height': menuVisible }">
  <div class="top-container" data-aos="fade-right">
    <div class="top-header-container">
      <a class="site-title-container" href="https://currydai.com">
        <img src="https://currydai.com/images/avatar.png?v=1621440894256" class="site-logo">
        <h1 class="site-title">Currydai</h1>
      </a>
      <div class="menu-btn" @click="menuVisible = !menuVisible">
        <div class="line"></div>
      </div>
    </div>
    <div>
      
        
          <a href="/" class="site-nav">
            Home
          </a>
        
      
        
          <a href="/archives" class="site-nav">
            Table of Contents
          </a>
        
      
        
          <a href="/tags" class="site-nav">
            Classification label
          </a>
        
      
        
          <a href="/post/about" class="site-nav">
            About me
          </a>
        
      
    </div>
  </div>
  <div class="bottom-container" data-aos="flip-up" data-aos-offset="0">
    <div class="social-container">
      
        
          <a class="social-link" href="http://currydai@github.com/" target="_blank">
            <i class="fab fa-github"></i>
          </a>
        
      
        
          <a class="social-link" href="https://twitter.com/daihb30" target="_blank">
            <i class="fab fa-twitter"></i>
          </a>
        
      
        
          <a class="social-link" href="https://weibo.com/u/5951669823" target="_blank">
            <i class="fab fa-weibo"></i>
          </a>
        
      
        
          <a class="social-link" href="https://www.zhihu.com/people/ka-li-35-76" target="_blank">
            <i class="fab fa-zhihu"></i>
          </a>
        
      
        
      
    </div>
    <div class="site-description">
      Share interesting things
    </div>
    <div class="site-footer">
      Powered by <a href="http://currydai@github.com/" target="_blank">Currydai</a> | <a class="rss" href="https://currydai.com/atom.xml" target="_blank">RSS</a>
    </div>
  </div>
</div>


      <div class="main-container">
        <div class="content-container" data-aos="fade-up">
          <div class="post-detail">
            <h2 class="post-title">【编程】常用设计模式总结(上)</h2>
            <div class="post-date">2021-02-23</div>
            
            <div class="post-content" v-pre>
              <h2 id="1设计模式">1.设计模式</h2>
<p><strong>设计模式主要是为了解决某类重复出现的问题而出现的一套成功或有效的解决方案</strong>，设计模式提供一种讨论软件设计的公共语言，使得熟练设计者的设计经验可以被初学者和其他设计者掌握。设计模式还为软件重构提供了目标。 每个模式都描述了一个在我们的环境中不断出现的问题，然后描述了该问题的解决方案的核心，通过这种方式，我们可以无数次地重用那些已有的成功的解决方案，无须再重复相同的工作。<br>
1991年，四人组GoF（Gang of Four，Erich Gamma、Richard Helm、Ralph Johnson 和 John Vlissides）最早将模式应用于软件工程方法学，他们归纳发表了<strong>23种</strong>在软件开发中使用频率较高的设计模式，<strong>旨在用模式来统一沟通面向对象方法在分析、设计和实现间的鸿沟</strong>，由此，软件设计模式诞生了！<br>
设计模式一般包含模式名称、问题、目的、解决方案、效果等要素：</p>
<ul>
<li>模式名称(Pattern Name)：通过一两个词来描述模式的问题、解决方案和效果，以便更好地理解模式并方便开发人员之间的交流，绝大多数模式都是根据其功能或模式结构来命名的；</li>
<li>问题(Problem)：描述应该在何时使用模式，包含了设计中存在的问题以及问题存在的原因；</li>
<li>解决方案(Solution)：描述一个设计模式的组成成分，以及这些组成成分之间的相互关系，各自的职责和协作方式，通常解决方案通过UML类图和核心代码来进行描述；</li>
<li>效果(Consequences)：描述了模式的优缺点以及在使用模式时应权衡的问题。</li>
</ul>
<p>狭义的设计模式一般分为3大类共计23种（广义上说，随着软件技术的逐步发展，不断有新的设计模式被总结出来并应用到工程实践中），如下表。其中，创建型模式关注对象的创建过程，结构性模式关注如何将现有类或对象组织在一起形成更加强大的结构，行为型模式关注系统中对象之间的交互研究系统在运行时对象之间的相互通信与协作，进一步明确对象的职责。<br>
<img src="https://currydai.com/post-images/1614053718714.png" alt="" loading="lazy"></p>
<p>设计模式是从众多优秀的软件系统中总结出的成功的、能够实现可维护性复用的设计方案，使用这些方案将避免一些重复性工作，高效设计出高质量的软件系统。总的来说，设计模式主要有以下优点：</p>
<p>设计模式融合了众多专家的经验，以一种标准的形式供广大开发人员使用，通俗的设计词汇和通用的语言方便开发人员交流和学习；</p>
<ul>
<li>设计模式使人们可以更简单方便地复用成功的设计，使新开发者更容易理解设计思路；</li>
<li>设计模式使设计方案更加灵活、易于修改；</li>
<li>设计模式的使用将提高软件系统的开发效率和软件质量，节约开发成本；</li>
<li>设计模式有助于初学者深入理解面向对象思想。</li>
</ul>
<h2 id="2uml类图介绍">2.UML类图介绍</h2>
<p>UML-Unified Model Language 统一建模语言，是在开发阶段，说明、可视化、构建和书写一个面向对象软件的开放方法。统一建模语言（UML）是一种模型化语言，通过一系列标准的图形符号来描述系统。一份典型的建模图表通常包含几个块或框，连接线和作为模型附加信息之用的文本。UML类图是用户将所希望描述的事物抽象为类，描述类的内部结构和类之间关系的设计视图。<br>
在UML类图中，常有以下几种关系：泛化(Generalization)、实现(Realization)、关联(Association)、聚合(Aggregation)、组合(Composition)和依赖(Dependency)。按照关系的强弱顺序：泛化≥实现&gt;关联&gt;聚合&gt;组合&gt;依赖。<br>
<img src="https://currydai.com/post-images/1614053957390.png" alt="" loading="lazy"></p>
<h3 id="21-泛化generalization">2.1 泛化(Generalization)</h3>
<figure data-type="image" tabindex="1"><img src="https://currydai.com/post-images/1614054050117.png" alt="" loading="lazy"></figure>
<h3 id="22-实现realization">2.2 实现(Realization)</h3>
<figure data-type="image" tabindex="2"><img src="https://currydai.com/post-images/1614054065855.png" alt="" loading="lazy"></figure>
<h3 id="23-关联association">2.3 关联(Association)</h3>
<p>关联是一种拥有关系（has），一个类可以调用另一个类的公有的属性和方法。在类中以成员变量的方式表示。比如老师有自己的学生，知道学生的姓名学号成绩；学生有自己的老师，也知道老师的姓名和所教的科目。关联分为单向关联、双向关联和自关联。<br>
<img src="https://currydai.com/post-images/1614054217176.png" alt="" loading="lazy"><br>
<img src="https://currydai.com/post-images/1614054223069.png" alt="" loading="lazy"><br>
<img src="https://currydai.com/post-images/1614054227904.png" alt="" loading="lazy"><br>
<img src="https://currydai.com/post-images/1614054256768.png" alt="" loading="lazy"></p>
<h3 id="24-聚合aggregation">2.4 聚合(Aggregation)</h3>
<figure data-type="image" tabindex="3"><img src="https://currydai.com/post-images/1614054304109.png" alt="" loading="lazy"></figure>
<h3 id="25-组合composition">2.5 组合(Composition)</h3>
<figure data-type="image" tabindex="4"><img src="https://currydai.com/post-images/1614054347165.png" alt="" loading="lazy"></figure>
<h3 id="26-依赖dependency">2.6 依赖(Dependency)</h3>
<figure data-type="image" tabindex="5"><img src="https://currydai.com/post-images/1614054384156.png" alt="" loading="lazy"></figure>
<h2 id="3面向对象设计的原则">3.面向对象设计的原则</h2>
<p>设计模式需要遵循基本的软件设计原则。可维护性（Maintainability）和可复用性（Reusability）是衡量软件质量的重要的两个属性：</p>
<ul>
<li>可维护性：软件能够被理解、改正、适应及扩展的难易程度</li>
<li>可复用性：软件能够被复用的难易程度<br>
<strong>面向对象设计的原则是支持可维护性复用</strong>，一方面需要实现设计方案或代码的复用，另一方面要保证系统易于扩展和修改，具有良好的可维护性。面向对象设计原则蕴含在各个设计模式中，是学习设计模式的基石，也是用于评价某个设计模式效果（Consequence）的重要指标。<strong>常见的面向对象设计原则包括：单一职责原则、开闭原则、里氏代换原则、依赖倒转原则、接口隔离原则、合成复用原则、迪米特法则。</strong></li>
</ul>
<h3 id="31-单一职责原则">3.1 单一职责原则</h3>
<p>单一职责原则：<br>
定义1：一个对象应该只包含单一的职责，并且该职责被完整地封装在一个类中。<br>
定义2：就一个类而言，应该仅有一个引起它变化的原因。<br>
解释：<br>
高内聚：内聚是对软件系统中元素职责相关性和集中度的度量。如果元素具有高度相关的职责，除了这些职责内的任务，没有其它过多的工作，那么该元素就具有高内聚性；反之则成为低内聚性。<br>
低耦合：耦合是软件结构中各模块之间相互连接的一种度量，耦合强弱取决于模块间接口的复杂程度、进入或访问一个模块的点以及通过接口的数据。<br>
单一职责原则用于控制类的力度大小。软件设计过程中，如果一个类承担的职责越多，那么它被复用的可能性越小。另一方面，如果一个类承担的职责越多，各个职责耦合在一起，修改其中一个职责可能“牵一发而动全身”。因此，应该将这些职责进行分离，不同的职责封装在不同的类中。</p>
<h3 id="32-开闭原则">3.2 开闭原则</h3>
<p>开闭原则：软件实体应对扩展开放，对修改关闭。<br>
开闭原则指软件实体（一个软件模块、一个由不同类组成的局部结构或一个独立的类） 应该在不修改原有代码的基础上进行扩展。软件设计过程中，需求可能会随时变化，需要根据需求扩展已有的设计。如果原有的设计符合开闭原则，那么扩展起来就比较安全（不会影响原有功能，稳定）和方便（易于扩展）。开闭原则的关键在于抽象化。可以为系统定义一个相对较为稳定的抽象层，将不同的实现行为放到具体的实现层中完成。</p>
<h3 id="33里氏代换原则">3.3里氏代换原则</h3>
<p>历史替换原则：所有引用基类的地方必须能透明地使用其子类的对象。<br>
里氏代换原则的指导意义在于：尽可能地使用基类类型来对对象进行定义，而在运行时再确定子类类型，然后用子类对象替换父类对象。设计时应将父类设计为抽象类或者接口，子类继承父类并实现在父类中声明的方法；运行时子类实例（对象）替换父类实例（对象），可以很方便地扩展系统功能。</p>
<h3 id="34-依赖倒转原则">3.4 依赖倒转原则</h3>
<p>依赖倒转原则：高层模块不应该依赖低层模块，它们都应该依赖抽象。抽象不应该依赖于细节，细节应该依赖于抽象。<br>
依赖倒转原则要求再程序代码中传递参数时，或在关联关系中，尽量引用层次高的出现层类，即使用接口或抽象类来声明变量类型、参数类型声明、方法返回类型声明，以及数据类型转换等，而不要使用具体类来做这些事情。（其实这一点也符合里氏代换原则的指导意义，即对一个方法而言，返回基类的地方一定可以返回子类）。同样，依赖倒转原则设计的关键也在与抽象化设计。</p>
<h3 id="35-接口隔离原则">3.5 接口隔离原则</h3>
<p>接口隔离原则：客户端不应该依赖那些它不需要的接口。<br>
当一个接口太大时，应该将它根据需要分割成多个更细小的接口，每个接口仅承担一个相对独立的角色或功能，使用该接口的客户端仅需知道与之相关的方法即可。 但是，接口不能过小，否则系统中接口太多，不利于维护。一般而言，在接口中仅包含为某一类用户定制的方法即可。</p>
<h3 id="36合成复用原则">3.6合成复用原则</h3>
<p>合成复用原则：优先使用对象组合，而不是通过继承来达到复用的目的。<br>
根据UML类图关系，合成复用原则指导在软件设计时，优先使用关联、聚合和组合关系，尽量少用泛化（继承）。对象组合可以使系统更加灵活（黑箱复用），降低类与类之间的耦合度，一个类的变化尽可能不影响其他类（父类和子类耦合度高不高？）。如果要使用继承，则需考虑里氏代换原则和依赖倒转原则。继承关系会破坏系统的封装性，会将基类的实现细节暴露给子类（白箱复用），如果基类发生改变，那么子类的实现也不得不改变。</p>
<h3 id="37迪米特法则">3.7迪米特法则</h3>
<p>迪米特法则：每一个软件单位对其他单位都只有最少的知识，而且局限于那些与本单位密切相关的软件单位<br>
迪米特法则要求一个软件实体应当尽可能少地与其他实体发生相互作用。如果一个系统负荷迪米特法则，那么当修改其中某一个模块时就会尽量少地影响其他模块。应用迪米特法则可以降低系统的耦合度。在类的设计上应该注意以下几点：在类的划分上应尽量创建松耦合的类，类之间的耦合度越低，越有利于复用；类的结构设计上，每一个类都应该降低其成员变量和成员函数的访问权限。</p>

            </div>
            
            
              <div class="next-post">
                <div class="next">下一篇</div>
                <a href="https://currydai.com/post/shu-xue-ji-yu-hilbert-huang-bian-huan-de-qu-zao-suan-fa/">
                  <h3 class="post-title">
                    【数学】基于Hilbert-Huang变换的去噪算法
                  </h3>
                </a>
              </div>
            

            
              
                <div id="gitalk-container" data-aos="fade-in"></div>
              

              
            

          </div>

        </div>
      </div>
    </div>

    <script src="https://unpkg.com/aos@next/dist/aos.js"></script>
<script type="application/javascript">

AOS.init();

var app = new Vue({
  el: '#app',
  data: {
    menuVisible: false,
  },
})

</script>


  <script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
  <script>
    hljs.initHighlightingOnLoad()
  </script>




  
    <script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>
    <script>

      var gitalk = new Gitalk({
        clientID: 'e9e2094cbb62d2e4fdf8',
        clientSecret: 'e5f1fea8e3bc04931ca74fe4afd2051bc907e2b0',
        repo: 'blog-comments',
        owner: 'currydai',
        admin: ['currydai'],
        id: (location.pathname).substring(0, 49),      // Ensure uniqueness and length less than 50
        distractionFreeMode: false  // Facebook-like distraction free mode
      })

      gitalk.render('gitalk-container')

    </script>
  

  




  </body>
</html>
